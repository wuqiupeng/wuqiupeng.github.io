<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Kafka深度解析 - Kafka Stream | JAVA码农随笔</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Kafka,大数据">
    <meta name="description" content="Kafka Stream背景Kafka Stream是什么Kafka Stream是Apache Kafka从0.10版本引入的一个新Feature。它是提供了对存储于Kafka内的数据进行流式处理和分析的功能。Kafka Stream的特点如下：  Kafka Stream提供了一个非常简单而轻量的Library，它可以非常方便地嵌入任意Java应用中，也可以任意方式打包和部署 除了Kafka外">
<meta name="keywords" content="Kafka,大数据">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka深度解析 - Kafka Stream">
<meta property="og:url" content="https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/index.html">
<meta property="og:site_name" content="JAVA码农随笔">
<meta property="og:description" content="Kafka Stream背景Kafka Stream是什么Kafka Stream是Apache Kafka从0.10版本引入的一个新Feature。它是提供了对存储于Kafka内的数据进行流式处理和分析的功能。Kafka Stream的特点如下：  Kafka Stream提供了一个非常简单而轻量的Library，它可以非常方便地嵌入任意Java应用中，也可以任意方式打包和部署 除了Kafka外">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/stream_procissing.png">
<meta property="og:image" content="https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/batch_procissing.png">
<meta property="og:image" content="https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/library.png">
<meta property="og:image" content="https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/Kafka_Stream_Architecture.png">
<meta property="og:image" content="https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/1_thread.png">
<meta property="og:image" content="https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/2_threads.png">
<meta property="og:image" content="https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/2_instances.png">
<meta property="og:image" content="https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/2_servers.png">
<meta property="og:image" content="https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/ktable_kstream.png">
<meta property="og:image" content="https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/Hopping_Time_Window.gif">
<meta property="og:image" content="https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/Tumbling_Time_Window.gif">
<meta property="og:updated_time" content="2020-06-30T07:09:36.384Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kafka深度解析 - Kafka Stream">
<meta name="twitter:description" content="Kafka Stream背景Kafka Stream是什么Kafka Stream是Apache Kafka从0.10版本引入的一个新Feature。它是提供了对存储于Kafka内的数据进行流式处理和分析的功能。Kafka Stream的特点如下：  Kafka Stream提供了一个非常简单而轻量的Library，它可以非常方便地嵌入任意Java应用中，也可以任意方式打包和部署 除了Kafka外">
<meta name="twitter:image" content="https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/stream_procissing.png">
    
        <link rel="alternate" type="application/atom+xml" title="JAVA码农随笔" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">wuqiupeng</h5>
          <a href="mailto:wqp0010@gmail.com" title="wqp0010@gmail.com" class="mail">wqp0010@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives">
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags">
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/wuqiupeng/" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/u/2565125543/" target="_blank">
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Kafka深度解析 - Kafka Stream</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Kafka深度解析 - Kafka Stream</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-03-30T07:40:00.000Z" itemprop="datePublished" class="page-time">
  2019-03-30
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Kafka-Stream背景"><span class="post-toc-number">1.</span> <span class="post-toc-text">Kafka Stream背景</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Kafka-Stream是什么"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">Kafka Stream是什么</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#什么是流式计算"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">什么是流式计算</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#为什么要有Kafka-Stream"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">为什么要有Kafka Stream</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Kafka-Stream架构"><span class="post-toc-number">2.</span> <span class="post-toc-text">Kafka Stream架构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Kafka-Stream整体架构"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">Kafka Stream整体架构</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Processor-Topology"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">Processor Topology</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Kafka-Stream并行模型"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">Kafka Stream并行模型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#KTable-vs-KStream"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">KTable vs. KStream</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#State-store"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">State store</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Kafka-Stream如何解决流式系统中关键问题"><span class="post-toc-number">3.</span> <span class="post-toc-text">Kafka Stream如何解决流式系统中关键问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#时间"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">时间</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#窗口"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">窗口</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Join"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">Join</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#聚合与乱序处理"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">聚合与乱序处理</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#容错"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">容错</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#总结"><span class="post-toc-number">4.</span> <span class="post-toc-text">总结</span></a></li></ol>
        </nav>
    </aside>


<article id="post-Kafka深度解析-Kafka-Stream" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Kafka深度解析 - Kafka Stream</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-03-30 07:40:00" datetime="2019-03-30T07:40:00.000Z" itemprop="datePublished">2019-03-30</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h4 id="Kafka-Stream背景"><a href="#Kafka-Stream背景" class="headerlink" title="Kafka Stream背景"></a>Kafka Stream背景</h4><h5 id="Kafka-Stream是什么"><a href="#Kafka-Stream是什么" class="headerlink" title="Kafka Stream是什么"></a>Kafka Stream是什么</h5><p>Kafka Stream是Apache Kafka从0.10版本引入的一个新Feature。它是提供了对存储于Kafka内的数据进行流式处理和分析的功能。<br><br>Kafka Stream的特点如下：<br></p>
<ul>
<li>Kafka Stream提供了一个非常简单而轻量的Library，它可以非常方便地嵌入任意Java应用中，也可以任意方式打包和部署</li>
<li>除了Kafka外，无任何外部依赖</li>
<li>充分利用Kafka分区机制实现水平扩展和顺序性保证</li>
<li>通过可容错的state store实现高效的状态操作（如windowed join和aggregation）</li>
<li>支持正好一次处理语义</li>
<li>提供记录级的处理能力，从而实现毫秒级的低延迟</li>
<li>支持基于事件时间的窗口操作，并且可处理晚到的数据（late arrival of records）</li>
<li>同时提供底层的处理原语Processor（类似于Storm的spout和bolt），以及高层抽象的DSL（类似于Spark的map/group/reduce）</li>
</ul>
<h5 id="什么是流式计算"><a href="#什么是流式计算" class="headerlink" title="什么是流式计算"></a>什么是流式计算</h5><p>一般流式计算会与批量计算相比较。在流式计算模型中，输入是持续的，可以认为在时间上是无界的，也就意味着，永远拿不到全量数据去做计算。同时，计算结果是持续输出的，也即计算结果在时间上也是无界的。流式计算一般对实时性要求较高，同时一般是先定义目标计算，然后数据到来之后将计算逻辑应用于数据。同时为了提高计算效率，往往尽可能采用增量计算代替全量计算。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/30/Kafka深度解析-Kafka-Stream/stream_procissing.png" alt="stream_procissing" title="">
                </div>
                <div class="image-caption">stream_procissing</div>
            </figure>
<p>批量处理模型中，一般先有全量数据集，然后定义计算逻辑，并将计算应用于全量数据。特点是全量计算，并且计算结果一次性全量输出。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/30/Kafka深度解析-Kafka-Stream/batch_procissing.png" alt="batch_procissing" title="">
                </div>
                <div class="image-caption">batch_procissing</div>
            </figure>
<h5 id="为什么要有Kafka-Stream"><a href="#为什么要有Kafka-Stream" class="headerlink" title="为什么要有Kafka Stream"></a>为什么要有Kafka Stream</h5><p>当前已经有非常多的流式处理系统，最知名且应用最多的开源流式处理系统有Spark Streaming和Apache Storm。Apache Storm发展多年，应用广泛，提供记录级别的处理能力，当前也支持SQL on Stream。而Spark Streaming基于Apache Spark，可以非常方便与图计算，SQL处理等集成，功能强大，对于熟悉其它Spark应用开发的用户而言使用门槛低。另外，目前主流的Hadoop发行版，如MapR，Cloudera和Hortonworks，都集成了Apache Storm和Apache Spark，使得部署更容易。<br><br>既然Apache Spark与Apache Storm拥用如此多的优势，那为何还需要Kafka Stream呢？笔者认为主要有如下原因。<br><br>第一，Spark和Storm都是流式处理框架，而Kafka Stream提供的是一个基于Kafka的流式处理类库。框架要求开发者按照特定的方式去开发逻辑部分，供框架调用。开发者很难了解框架的具体运行方式，从而使得调试成本高，并且使用受限。而Kafka Stream作为流式处理类库，直接提供具体的类给开发者调用，整个应用的运行方式主要由开发者控制，方便使用和调试。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/30/Kafka深度解析-Kafka-Stream/library.png" alt="library" title="">
                </div>
                <div class="image-caption">library</div>
            </figure><br>第二，虽然Cloudera与Hortonworks方便了Storm和Spark的部署，但是这些框架的部署仍然相对复杂。而Kafka Stream作为类库，可以非常方便的嵌入应用程序中，它对应用的打包和部署基本没有任何要求。更为重要的是，Kafka Stream充分利用了Kafka的分区机制和Consumer的Rebalance机制，使得Kafka Stream可以非常方便的水平扩展，并且各个实例可以使用不同的部署方式。具体来说，每个运行Kafka Stream的应用程序实例都包含了Kafka Consumer实例，多个同一应用的实例之间并行处理数据集。而不同实例之间的部署方式并不要求一致，比如部分实例可以运行在Web容器中，部分实例可运行在Docker或Kubernetes中。<br><br>第三，就流式处理系统而言，基本都支持Kafka作为数据源。例如Storm具有专门的kafka-spout，而Spark也提供专门的spark-streaming-kafka模块。事实上，Kafka基本上是主流的流式处理系统的标准数据源。换言之，大部分流式系统中都已部署了Kafka，此时使用Kafka Stream的成本非常低。<br><br>第四，使用Storm或Spark Streaming时，需要为框架本身的进程预留资源，如Storm的supervisor和Spark on YARN的node manager。即使对于应用实例而言，框架本身也会占用部分资源，如Spark Streaming需要为shuffle和storage预留内存。<br><br>第五，由于Kafka本身提供数据持久化，因此Kafka Stream提供滚动部署和滚动升级以及重新计算的能力。<br><br>第六，由于Kafka Consumer Rebalance机制，Kafka Stream可以在线动态调整并行度。<br></p>
<h4 id="Kafka-Stream架构"><a href="#Kafka-Stream架构" class="headerlink" title="Kafka Stream架构"></a>Kafka Stream架构</h4><h5 id="Kafka-Stream整体架构"><a href="#Kafka-Stream整体架构" class="headerlink" title="Kafka Stream整体架构"></a>Kafka Stream整体架构</h5><p>Kafka Stream的整体架构图如下所示。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/30/Kafka深度解析-Kafka-Stream/Kafka_Stream_Architecture.png" alt="Kafka_Stream_Architecture" title="">
                </div>
                <div class="image-caption">Kafka_Stream_Architecture</div>
            </figure><br>Kafka Stream的数据源只能如上图所示是Kafka。但是处理结果并不一定要如上图所示输出到Kafka。实际上KStream和Ktable的实例化都需要指定Topic。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">KStream&lt;String, String&gt; stream = builder.stream(<span class="string">"words-stream"</span>);</span><br><span class="line"></span><br><span class="line">KTable&lt;String, String&gt; table = builder.table(<span class="string">"words-table"</span>, <span class="string">"words-store"</span>);</span><br></pre></td></tr></table></figure>
<p>另外，上图中的Consumer和Producer并不需要开发者在应用中显示实例化，而是由Kafka Stream根据参数隐式实例化和管理，从而降低了使用门槛。开发者只需要专注于开发核心业务逻辑，也即上图中Task内的部分。</p>
<h5 id="Processor-Topology"><a href="#Processor-Topology" class="headerlink" title="Processor Topology"></a>Processor Topology</h5><p>基于Kafka Stream的流式应用的业务逻辑全部通过一个被称为Processor Topology的地方执行。它与Storm的Topology和Spark的DAG类似，都定义了数据在各个处理单元（在Kafka Stream中被称作Processor）间的流动方式，或者说定义了数据的处理逻辑。<br><br>下面是一个Processor的示例，它实现了Word Count功能，并且每秒输出一次结果。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountProcessor</span> <span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ProcessorContext context;</span><br><span class="line">  <span class="keyword">private</span> KeyValueStore&lt;String, Integer&gt; kvStore;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessorContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line">    <span class="keyword">this</span>.context.schedule(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">this</span>.kvStore = (KeyValueStore&lt;String, Integer&gt;) context.getStateStore(<span class="string">"Counts"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    Stream.of(value.toLowerCase().split(<span class="string">" "</span>)).forEach((String word) -&gt; &#123;</span><br><span class="line">      Optional&lt;Integer&gt; counts = Optional.ofNullable(kvStore.get(word));</span><br><span class="line">      <span class="keyword">int</span> count = counts.map(wordcount -&gt; wordcount + <span class="number">1</span>).orElse(<span class="number">1</span>);</span><br><span class="line">      kvStore.put(word, count);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">punctuate</span><span class="params">(<span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line">    KeyValueIterator&lt;String, Integer&gt; iterator = <span class="keyword">this</span>.kvStore.all();</span><br><span class="line">    iterator.forEachRemaining(entry -&gt; &#123;</span><br><span class="line">      context.forward(entry.key, entry.value);</span><br><span class="line">      <span class="keyword">this</span>.kvStore.delete(entry.key);</span><br><span class="line">    &#125;);</span><br><span class="line">    context.commit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.kvStore.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上述代码中可见</p>
<ul>
<li>process定义了对每条记录的处理逻辑，也印证了Kafka可具有记录级的数据处理能力。</li>
<li>context.scheduler定义了punctuate被执行的周期，从而提供了实现窗口操作的能力。</li>
<li>context.getStateStore提供的状态存储为有状态计算（如窗口，聚合）提供了可能。</li>
</ul>
<h5 id="Kafka-Stream并行模型"><a href="#Kafka-Stream并行模型" class="headerlink" title="Kafka Stream并行模型"></a>Kafka Stream并行模型</h5><p>Kafka Stream的并行模型中，最小粒度为Task，而每个Task包含一个特定子Topology的所有Processor。因此每个Task所执行的代码完全一样，唯一的不同在于所处理的数据集互补。这一点跟Storm的Topology完全不一样。Storm的Topology的每一个Task只包含一个Spout或Bolt的实例。因此Storm的一个Topology内的不同Task之间需要通过网络通信传递数据，而Kafka Stream的Task包含了完整的子Topology，所以Task之间不需要传递数据，也就不需要网络通信。这一点降低了系统复杂度，也提高了处理效率。<br><br>如果某个Stream的输入Topic有多个(比如2个Topic，1个Partition数为4，另一个Partition数为3)，则总的Task数等于Partition数最多的那个Topic的Partition数（max(4,3)=4）。这是因为Kafka Stream使用了Consumer的Rebalance机制，每个Partition对应一个Task。<br><br>下图展示了在一个进程（Instance）中以2个Topic（Partition数均为4）为数据源的Kafka Stream应用的并行模型。从图中可以看到，由于Kafka Stream应用的默认线程数为1，所以4个Task全部在一个线程中运行。<br></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/30/Kafka深度解析-Kafka-Stream/1_thread.png" alt="1_thread" title="">
                </div>
                <div class="image-caption">1_thread</div>
            </figure>
<p>为了充分利用多线程的优势，可以设置Kafka Stream的线程数。下图展示了线程数为2时的并行模型。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/30/Kafka深度解析-Kafka-Stream/2_threads.png" alt="2_threads" title="">
                </div>
                <div class="image-caption">2_threads</div>
            </figure>
<p>前文有提到，Kafka Stream可被嵌入任意Java应用（理论上基于JVM的应用都可以）中，下图展示了在同一台机器的不同进程中同时启动同一Kafka Stream应用时的并行模型。注意，这里要保证两个进程的StreamsConfig.APPLICATION_ID_CONFIG完全一样。因为Kafka Stream将APPLICATION_ID_CONFIG作为隐式启动的Consumer的Group ID。只有保证APPLICATION_ID_CONFIG相同，才能保证这两个进程的Consumer属于同一个Group，从而可以通过Consumer Rebalance机制拿到互补的数据集。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/30/Kafka深度解析-Kafka-Stream/2_instances.png" alt="2_instances" title="">
                </div>
                <div class="image-caption">2_instances</div>
            </figure>
<p>既然实现了多进程部署，可以以同样的方式实现多机器部署。该部署方式也要求所有进程的APPLICATION_ID_CONFIG完全一样。从图上也可以看到，每个实例中的线程数并不要求一样。但是无论如何部署，Task总数总会保证一致。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/30/Kafka深度解析-Kafka-Stream/2_servers.png" alt="2_servers" title="">
                </div>
                <div class="image-caption">2_servers</div>
            </figure>
<p>这里对比一下Kafka Stream的Processor Topology与Storm的Topology。</p>
<ul>
<li>Storm的Topology由Spout和Bolt组成，Spout提供数据源，而Bolt提供计算和数据导出。Kafka Stream的Processor Topology完全由Processor组成，因为它的数据固定由Kafka的Topic提供。</li>
<li>Storm的不同Bolt运行在不同的Executor中，很可能位于不同的机器，需要通过网络通信传输数据。而Kafka Stream的Processor Topology的不同Processor完全运行于同一个Task中，也就完全处于同一个线程，无需网络通信。</li>
<li>Storm的Topology可以同时包含Shuffle部分和非Shuffle部分，并且往往一个Topology就是一个完整的应用。而Kafka Stream的一个物理Topology只包含非Shuffle部分，而Shuffle部分需要通过through操作显示完成，该操作将一个大的Topology分成了2个子Topology。</li>
<li>Storm的Topology内，不同Bolt/Spout的并行度可以不一样，而Kafka Stream的子Topology内，所有Processor的并行度完全一样。</li>
<li>Storm的一个Task只包含一个Spout或者Bolt的实例，而Kafka Stream的一个Task包含了一个子Topology的所有Processor。</li>
</ul>
<h5 id="KTable-vs-KStream"><a href="#KTable-vs-KStream" class="headerlink" title="KTable vs. KStream"></a>KTable vs. KStream</h5><p>KTable和KStream是Kafka Stream中非常重要的两个概念，它们是Kafka实现各种语义的基础。因此这里有必要分析下二者的区别。<br><br>KStream是一个数据流，可以认为所有记录都通过Insert only的方式插入进这个数据流里。而KTable代表一个完整的数据集，可以理解为数据库中的表。由于每条记录都是Key-Value对，这里可以将Key理解为数据库中的Primary Key，而Value可以理解为一行记录。可以认为KTable中的数据都是通过Update only的方式进入的。也就意味着，如果KTable对应的Topic中新进入的数据的Key已经存在，那么从KTable只会取出同一Key对应的最后一条数据，相当于新的数据更新了旧的数据。<br><br>以下图为例，假设有一个KStream和KTable，基于同一个Topic创建，并且该Topic中包含如下图所示5条数据。此时遍历KStream将得到与Topic内数据完全一样的所有5条数据，且顺序不变。而此时遍历KTable时，因为这5条记录中有3个不同的Key，所以将得到3条记录，每个Key对应最新的值，并且这三条数据之间的顺序与原来在Topic中的顺序保持一致。这一点与Kafka的日志compact相同。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/30/Kafka深度解析-Kafka-Stream/ktable_kstream.png" alt="ktable_kstream" title="">
                </div>
                <div class="image-caption">ktable_kstream</div>
            </figure>
<p>此时如果对该KStream和KTable分别基于key做Group，对Value进行Sum，得到的结果将会不同。对KStream的计算结果是&lt;Jack，4&gt;，&lt;Lily，7&gt;，&lt;Mike，4&gt;。而对Ktable的计算结果是&lt;Mike，4&gt;，&lt;Jack，3&gt;，&lt;Lily，5&gt;。</p>
<h5 id="State-store"><a href="#State-store" class="headerlink" title="State store"></a>State store</h5><p>流式处理中，部分操作是无状态的，例如过滤操作（Kafka Stream DSL中用filer方法实现）。而部分操作是有状态的，需要记录中间状态，如Window操作和聚合计算。State store被用来存储中间状态。它可以是一个持久化的Key-Value存储，也可以是内存中的HashMap，或者是数据库。Kafka提供了基于Topic的状态存储。<br><br>Topic中存储的数据记录本身是Key-Value形式的，同时Kafka的log compaction机制可对历史数据做compact操作，保留每个Key对应的最后一个Value，从而在保证Key不丢失的前提下，减少总数据量，从而提高查询效率。<br><br>构造KTable时，需要指定其state store name。默认情况下，该名字也即用于存储该KTable的状态的Topic的名字，遍历KTable的过程，实际就是遍历它对应的state store，或者说遍历Topic的所有key，并取每个Key最新值的过程。为了使得该过程更加高效，默认情况下会对该Topic进行compact操作。<br><br>另外，除了KTable，所有状态计算，都需要指定state store name，从而记录中间状态。</p>
<h4 id="Kafka-Stream如何解决流式系统中关键问题"><a href="#Kafka-Stream如何解决流式系统中关键问题" class="headerlink" title="Kafka Stream如何解决流式系统中关键问题"></a>Kafka Stream如何解决流式系统中关键问题</h4><h5 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h5><p>在流式数据处理中，时间是数据的一个非常重要的属性。从Kafka 0.10开始，每条记录除了Key和Value外，还增加了timestamp属性。目前Kafka Stream支持三种时间</p>
<ul>
<li>事件发生时间。事件发生的时间，包含在数据记录中。发生时间由Producer在构造ProducerRecord时指定。并且需要Broker或者Topic将message.timestamp.type设置为CreateTime（默认值）才能生效。</li>
<li>消息接收时间，也即消息存入Broker的时间。当Broker或Topic将message.timestamp.type设置为LogAppendTime时生效。此时Broker会在接收到消息后，存入磁盘前，将其timestamp属性值设置为当前机器时间。一般消息接收时间比较接近于事件发生时间，部分场景下可代替事件发生时间。</li>
<li>消息处理时间，也即Kafka Stream处理消息时的时间。<br>注：Kafka Stream允许通过实现org.apache.kafka.streams.processor.TimestampExtractor接口自定义记录时间</li>
</ul>
<h5 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h5><p>前文提到，流式数据是在时间上无界的数据。而聚合操作只能作用在特定的数据集，也即有界的数据集上。因此需要通过某种方式从无界的数据集上按特定的语义选取出有界的数据。窗口是一种非常常用的设定计算边界的方式。不同的流式处理系统支持的窗口类似，但不尽相同。</p>
<p>Kafka Stream支持的窗口如下。</p>
<ul>
<li>Hopping Time Window 该窗口定义如下图所示。它有两个属性，一个是Window size，一个是Advance interval。Window size指定了窗口的大小，也即每次计算的数据集的大小。而Advance interval定义输出的时间间隔。一个典型的应用场景是，每隔5秒钟输出一次过去1个小时内网站的PV或者UV。</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/30/Kafka深度解析-Kafka-Stream/Hopping_Time_Window.gif" alt="Hopping_Time_Window" title="">
                </div>
                <div class="image-caption">Hopping_Time_Window</div>
            </figure>
<ul>
<li>Tumbling Time Window该窗口定义如下图所示。可以认为它是Hopping Time Window的一种特例，也即Window size和Advance interval相等。它的特点是各个Window之间完全不相交。</li>
</ul>
<p><img src="/2019/03/30/Kafka深度解析-Kafka-Stream/Tumbling_Time_Window.gif" alt="Tumbling_Time_Window"></p>
<ul>
<li><p>Sliding Window该窗口只用于2个KStream进行Join计算时。该窗口的大小定义了Join两侧KStream的数据记录被认为在同一个窗口的最大时间差。假设该窗口的大小为5秒，则参与Join的2个KStream中，记录时间差小于5的记录被认为在同一个窗口中，可以进行Join计算。</p>
</li>
<li><p>Session Window该窗口用于对Key做Group后的聚合操作中。它需要对Key做分组，然后对组内的数据根据业务需求定义一个窗口的起始点和结束点。一个典型的案例是，希望通过Session Window计算某个用户访问网站的时间。对于一个特定的用户（用Key表示）而言，当发生登录操作时，该用户（Key）的窗口即开始，当发生退出操作或者超时时，该用户（Key）的窗口即结束。窗口结束时，可计算该用户的访问时间或者点击次数等。</p>
</li>
</ul>
<h5 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h5><p>Kafka Stream由于包含KStream和Ktable两种数据集，因此提供如下Join计算</p>
<ul>
<li>KTable Join KTable 结果仍为KTable。任意一边有更新，结果KTable都会更新。</li>
<li>KStream Join KStream 结果为KStream。必须带窗口操作，否则会造成Join操作一直不结束。</li>
<li>KStream Join KTable / GlobalKTable 结果为KStream。只有当KStream中有新数据时，才会触发Join计算并输出结果。KStream无新数据时，KTable的更新并不会触发Join计算，也不会输出数据。并且该更新只对下次Join生效。一个典型的使用场景是，KStream中的订单信息与KTable中的用户信息做关联计算。<br></li>
</ul>
<p>对于Join操作，如果要得到正确的计算结果，需要保证参与Join的KTable或KStream中Key相同的数据被分配到同一个Task。具体方法是</p>
<ul>
<li>参与Join的KTable或KStream的Key类型相同（实际上，业务含意也应该相同）</li>
<li>参与Join的KTable或KStream对应的Topic的Partition数相同<br>Partitioner策略的最终结果等效（实现不需要完全一样，只要效果一样即可），也即Key相同的情况下，被分配到ID相同的Partition内<br></li>
</ul>
<p>如果上述条件不满足，可通过调用如下方法使得它满足上述条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">KStream&lt;K, V&gt; <span class="title">through</span><span class="params">(Serde&lt;K&gt; keySerde, Serde&lt;V&gt; valSerde, StreamPartitioner&lt;K, V&gt; partitioner, String topic)</span></span></span><br></pre></td></tr></table></figure>
<h5 id="聚合与乱序处理"><a href="#聚合与乱序处理" class="headerlink" title="聚合与乱序处理"></a>聚合与乱序处理</h5><p>聚合操作可应用于KStream和KTable。当聚合发生在KStream上时必须指定窗口，从而限定计算的目标数据集。<br><br>需要说明的是，聚合操作的结果肯定是KTable。因为KTable是可更新的，可以在晚到的数据到来时（也即发生数据乱序时）更新结果KTable。<br><br>这里举例说明。假设对KStream以5秒为窗口大小，进行Tumbling Time Window上的Count操作。并且KStream先后出现时间为1秒, 3秒, 5秒的数据，此时5秒的窗口已达上限，Kafka Stream关闭该窗口，触发Count操作并将结果3输出到KTable中（假设该结果表示为&lt;1-5,3&gt;）。若1秒后，又收到了时间为2秒的记录，由于1-5秒的窗口已关闭，若直接抛弃该数据，则可认为之前的结果&lt;1-5,3&gt;不准确。而如果直接将完整的结果&lt;1-5,4&gt;输出到KStream中，则KStream中将会包含该窗口的2条记录，&lt;1-5,3&gt;, &lt;1-5,4&gt;，也会存在肮数据。因此Kafka Stream选择将聚合结果存于KTable中，此时新的结果&lt;1-5,4&gt;会替代旧的结果&lt;1-5,3&gt;。用户可得到完整的正确的结果。<br><br>这种方式保证了数据准确性，同时也提高了容错性。<br><br>但需要说明的是，Kafka Stream并不会对所有晚到的数据都重新计算并更新结果集，而是让用户设置一个retention period，将每个窗口的结果集在内存中保留一定时间，该窗口内的数据晚到时，直接合并计算，并更新结果KTable。超过retention period后，该窗口结果将从内存中删除，并且晚到的数据即使落入窗口，也会被直接丢弃。</p>
<h5 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h5><p>Kafka Stream从如下几个方面进行容错</p>
<ul>
<li>高可用的Partition保证无数据丢失。每个Task计算一个Partition，而Kafka数据复制机制保证了Partition内数据的高可用性，故无数据丢失风险。同时由于数据是持久化的，即使任务失败，依然可以重新计算。</li>
<li>状态存储实现快速故障恢复和从故障点继续处理。对于Join和聚合及窗口等有状态计算，状态存储可保存中间状态。即使发生Failover或Consumer Rebalance，仍然可以通过状态存储恢复中间状态，从而可以继续从Failover或Consumer Rebalance前的点继续计算。</li>
<li>KTable与retention period提供了对乱序数据的处理能力。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>Kafka Stream的并行模型完全基于Kafka的分区机制和Rebalance机制，实现了在线动态调整并行度</li>
<li>同一Task包含了一个子Topology的所有Processor，使得所有处理逻辑都在同一线程内完成，避免了不必的网络通信开销，从而提高了效率。</li>
<li>through方法提供了类似Spark的Shuffle机制，为使用不同分区策略的数据提供了Join的可能<br>log compact提高了基于Kafka的state store的加载效率</li>
<li>state store为状态计算提供了可能</li>
<li>基于offset的计算进度管理以及基于state store的中间状态管理为发生Consumer rebalance或Failover时从断点处继续处理提供了可能，并为系统容错性提供了保障</li>
<li>KTable的引入，使得聚合计算拥用了处理乱序问题的能力</li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <footer>
        <a href="https://www.wqp0010.top">
            <img src="/img/avatar.jpg" alt="wuqiupeng">
            wuqiupeng
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kafka/">Kafka</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/大数据/">大数据</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/&title=《Kafka深度解析 - Kafka Stream》 — JAVA码农随笔&pic=https://www.wqp0010.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/&title=《Kafka深度解析 - Kafka Stream》 — JAVA码农随笔&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Kafka深度解析 - Kafka Stream》 — JAVA码农随笔&url=https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/&via=https://www.wqp0010.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/03/15/Kafka深度解析/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Kafka深度解析</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "mVF5KCUIVcjCDpIqP4dcKWXw-gzGzoHsz",
            appKey: "JWj2x2gTJhQ82wlAVNAB3rkI",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>wuqiupeng &copy; 2015 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/&title=《Kafka深度解析 - Kafka Stream》 — JAVA码农随笔&pic=https://www.wqp0010.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/&title=《Kafka深度解析 - Kafka Stream》 — JAVA码农随笔&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Kafka深度解析 - Kafka Stream》 — JAVA码农随笔&url=https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/&via=https://www.wqp0010.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.wqp0010.top/2019/03/30/Kafka深度解析-Kafka-Stream/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACvElEQVR42u3aQY4bMQwEwP3/pzdATgESj7tJaeNDzSnweizVBLDoJr++4uv79/Xqle8/ruSvf7/+6j3Pn3DswsPDwxtt/Xmx51eet5g8muSxzlbHw8PDu8dLPnq2rVcbytfKHwoeHh7ep/GSerU9bPYlOx4eHt7n85KiuS2Rn6MHPDw8vM/k5V/iSYmcF+jt0XIxa8HDw8OLeZsv9P/174v9PTw8PLxFV31zSLQxxCz4eLMWHh4e3gVeEsW2I1DP+PZz2pI9+sWAh4eHd4iXRwbt5vKgto2GozEvPDw8vKO89kjIH0fxdMsGWHLM4OHh4d3j1WdIXEDvY+JTDx0PDw/vHq+ND5Jwtr1rVkyvGmN4eHh4JW+zWF46z9r/bczxj1Xw8PDwLvCGNxxqd7VHy7Bkx8PDw7vASyKA9vBIavmzd0UDBHh4eHhr3ilGG1jkA6yzSDf6b8XDw8Ob/+qvRwHau2bHQBttvAkj8PDw8A7x8v7YPmI4u1Y9U4aHh4d3iNdufVY6b7r5MxIeHh7ePV67uXYgYPaePHR4s3M8PDy8a7x2OCAvc1vwflgBDw8P72d4ecO+LX9njavZSMGb3wp4eHh4R3l5kZq0tdoSPFkx38PLcw8PDw/vKK8YYIqPk1mkmwTExRAYHh4e3gVeWzTPtpVvYt8Ye/k48PDw8A7x8uK1bYk9b3fT1iruxcPDw/txXtSeX1+z4CMKiPHw8PAu8GZDAHksO6vxNw2zKIzAw8PDW/C+y2sfts4GrYYPCA8PD+8Cb1P47svl2UhB3mDDw8PDu8drI4nkiz4JfNv3zIYJ8PDw8O7x8sPg7JBBG+auzjQ8PDy8H+flG2rHDmaRbjFNhoeHh/cxvM241azZlve28PDw8G7z9l/u9+KMvHyvBwjw8PDwRrxNA+zs8ZA3xo519vDw8PA63i8WJpxxJ4xi2gAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


lazyScripts.push('//s95.cnzz.com/z_stat.php?id=1278014607&web_id=1278014607')

</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
